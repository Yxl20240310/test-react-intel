import { createRequire } from 'module';
var require = createRequire(import.meta['url']);


// ../../node_modules/.pnpm/@modern-js+module-tools@2.52.0_eslint@9.5.0_typescript@5.4.5/node_modules/@modern-js/module-tools/shims/esm.js
import { fileURLToPath } from "url";
import path from "path";

// src/index.ts
import fse2 from "../compiled/fs-extra/index.js";

// src/constants.ts
var DEFAULT_WEB_BROWSERSLIST = [
  "chrome >= 87",
  "edge >= 88",
  "firefox >= 78",
  "safari >= 14"
];
var DEFAULT_BROWSERSLIST = {
  web: DEFAULT_WEB_BROWSERSLIST,
  "web-worker": DEFAULT_WEB_BROWSERSLIST,
  "service-worker": DEFAULT_WEB_BROWSERSLIST,
  node: ["node >= 16"]
};
var DEFAULT_ASSET_PREFIX = "/";
var JS_REGEX = /\.(?:js|mjs|cjs|jsx)$/;
var SCRIPT_REGEX = /\.(?:js|jsx|mjs|cjs|ts|tsx|mts|cts)$/;
var TS_AND_JSX_REGEX = /\.(?:ts|tsx|jsx|mts|cts)$/;
var NODE_MODULES_REGEX = /[\\/]node_modules[\\/]/;

// src/utils.ts
import deepmerge from "../compiled/deepmerge/index.js";
import fse from "../compiled/fs-extra/index.js";
import color from "../compiled/picocolors/index.js";
var getNodeEnv = () => process.env.NODE_ENV;
var setNodeEnv = (env) => {
  process.env.NODE_ENV = env;
};
var isDev = () => getNodeEnv() === "development";
var isProd = () => getNodeEnv() === "production";
var isFunction = (func) => typeof func === "function";
var isObject = (obj) => obj !== null && typeof obj === "object";
var isPlainObject = (obj) => isObject(obj) && Object.prototype.toString.call(obj) === "[object Object]";
var isNil = (o) => o === void 0 || o === null;
var getCoreJsVersion = (corejsPkgPath) => {
  try {
    const { version } = fse.readJSONSync(corejsPkgPath);
    const [major, minor] = version.split(".");
    return `${major}.${minor}`;
  } catch (err) {
    return "3";
  }
};
var castArray = (arr) => {
  if (arr === void 0) {
    return [];
  }
  return Array.isArray(arr) ? arr : [arr];
};
var cloneDeep = (value) => {
  if (value === null || value === void 0) {
    return value;
  }
  return deepmerge({}, value);
};
var DEP_MATCH_TEMPLATE = /[\\/]node_modules[\\/](<SOURCES>)[\\/]/.source;
var createDependenciesRegExp = (...dependencies) => {
  const sources = dependencies.map(
    (d) => typeof d === "string" ? d : d.source
  );
  const expr = DEP_MATCH_TEMPLATE.replace("<SOURCES>", sources.join("|"));
  return new RegExp(expr);
};
function createCacheGroups(group) {
  const experienceCacheGroup = {};
  for (const [name, pkgs] of Object.entries(group)) {
    const key = `lib-${name}`;
    experienceCacheGroup[key] = {
      test: createDependenciesRegExp(...pkgs),
      priority: 0,
      name: key,
      reuseExistingChunk: true
    };
  }
  return experienceCacheGroup;
}
var getPublicPathFromCompiler = (compiler) => {
  const { publicPath } = compiler.options.output;
  if (typeof publicPath === "string") {
    if (publicPath === "auto") {
      return "";
    }
    return publicPath.endsWith("/") ? publicPath : `${publicPath}/`;
  }
  return DEFAULT_ASSET_PREFIX;
};
var prettyTime = (seconds) => {
  const format = (time) => color.bold(time);
  if (seconds < 10) {
    const digits = seconds >= 0.01 ? 2 : 3;
    return `${format(seconds.toFixed(digits))} s`;
  }
  if (seconds < 60) {
    return `${format(seconds.toFixed(1))} s`;
  }
  const minutes = seconds / 60;
  return `${format(minutes.toFixed(2))} m`;
};
var isHtmlDisabled = (config, target) => {
  const { htmlPlugin } = config.tools;
  return htmlPlugin === false || Array.isArray(htmlPlugin) && htmlPlugin.includes(false) || target !== "web";
};
function isUsingHMR(config, { isProd: isProd2, target }) {
  return !isProd2 && config.dev.hmr && target === "web";
}

// src/getBrowserslist.ts
import browserslist from "../compiled/browserslist/index.js";
var browsersListCache = /* @__PURE__ */ new Map();
async function getBrowserslist(path2) {
  const env = getNodeEnv();
  const cacheKey = path2 + env;
  if (browsersListCache.has(cacheKey)) {
    return browsersListCache.get(cacheKey);
  }
  const result = browserslist.loadConfig({ path: path2, env });
  if (result) {
    browsersListCache.set(cacheKey, result);
    return result;
  }
  return null;
}
async function getBrowserslistWithDefault(path2, config, target) {
  const { overrideBrowserslist: overrides = {} } = config?.output || {};
  if (target === "web" || target === "web-worker") {
    if (Array.isArray(overrides)) {
      return overrides;
    }
    if (overrides[target]) {
      return overrides[target];
    }
    const browserslistrc = await getBrowserslist(path2);
    if (browserslistrc) {
      return browserslistrc;
    }
  }
  if (!Array.isArray(overrides) && overrides[target]) {
    return overrides[target];
  }
  return DEFAULT_BROWSERSLIST[target];
}
var ES_VERSIONS_MAP = {
  chrome: [51, 52, 57, 64],
  edge: [15, 15, 15, 79],
  safari: [10, 10.3, 11, 16.4],
  firefox: [54, 54, 54, 78],
  opera: [38, 39, 44, 51],
  samsung: [5, 6.2, 6.2, 8.2]
};
var renameBrowser = (name) => {
  return name === "ios_saf" ? "safari" : name;
};
function browserslistToESVersion(browsers) {
  const projectBrowsers = browserslist(browsers, {
    ignoreUnknownVersions: true
  });
  let esVersion = 2018 /* es2018 */;
  for (const item of projectBrowsers) {
    const pairs = item.split(" ");
    if (pairs.length < 2) {
      continue;
    }
    const browser = renameBrowser(pairs[0]);
    const version = Number(pairs[1].split("-")[0]);
    if (Number.isNaN(version)) {
      continue;
    }
    if (browser === "ie" || browser === "android" && version < 6) {
      esVersion = 5 /* es5 */;
      break;
    }
    const versions = ES_VERSIONS_MAP[browser];
    if (!versions) {
      continue;
    }
    if (version < versions[0]) {
      esVersion = Math.min(5 /* es5 */, esVersion);
    } else if (version < versions[1]) {
      esVersion = Math.min(2015 /* es2015 */, esVersion);
    } else if (version < versions[2]) {
      esVersion = Math.min(2016 /* es2016 */, esVersion);
    } else if (version < versions[3]) {
      esVersion = Math.min(2017 /* es2017 */, esVersion);
    }
  }
  return esVersion;
}

// src/reduceConfigs.ts
function reduceConfigs({
  initial,
  config,
  mergeFn = Object.assign
}) {
  if (isNil(config)) {
    return initial;
  }
  if (isPlainObject(config)) {
    return isPlainObject(initial) ? mergeFn(initial, config) : config;
  }
  if (isFunction(config)) {
    return config(initial) ?? initial;
  }
  if (Array.isArray(config)) {
    return config.reduce(
      (initial2, config2) => reduceConfigs({ initial: initial2, config: config2, mergeFn }),
      initial
    );
  }
  return config ?? initial;
}
function reduceConfigsWithContext({
  initial,
  config,
  ctx,
  mergeFn = Object.assign
}) {
  if (isNil(config)) {
    return initial;
  }
  if (isPlainObject(config)) {
    return isPlainObject(initial) ? mergeFn(initial, config) : config;
  }
  if (isFunction(config)) {
    return config(initial, ctx) ?? initial;
  }
  if (Array.isArray(config)) {
    return config.reduce(
      (initial2, config2) => reduceConfigsWithContext({ initial: initial2, config: config2, ctx, mergeFn }),
      initial
    );
  }
  return config ?? initial;
}
async function reduceConfigsAsyncWithContext({
  initial,
  config,
  ctx,
  mergeFn = Object.assign
}) {
  if (isNil(config)) {
    return initial;
  }
  if (isPlainObject(config)) {
    return isPlainObject(initial) ? mergeFn(initial, config) : config;
  }
  if (isFunction(config)) {
    return await config(initial, ctx) ?? initial;
  }
  if (Array.isArray(config)) {
    return config.reduce(
      (initial2, config2) => reduceConfigsWithContext({ initial: initial2, config: config2, ctx, mergeFn }),
      initial
    );
  }
  return config ?? initial;
}
function reduceConfigsMergeContext({
  initial,
  config,
  ctx,
  mergeFn = Object.assign
}) {
  if (isNil(config)) {
    return initial;
  }
  if (isPlainObject(config)) {
    return isPlainObject(initial) ? mergeFn(initial, config) : config;
  }
  if (isFunction(config)) {
    return config({ value: initial, ...ctx }) ?? initial;
  }
  if (Array.isArray(config)) {
    return config.reduce(
      (initial2, config2) => reduceConfigsMergeContext({
        initial: initial2,
        config: config2,
        ctx,
        mergeFn
      }),
      initial
    );
  }
  return config ?? initial;
}

// src/chain.ts
import RspackChain from "../compiled/rspack-chain/index.js";
var CHAIN_ID = {
  /** Predefined rules */
  RULE: {
    /** Rule for .mjs */
    MJS: "mjs",
    /** Rule for fonts */
    FONT: "font",
    /** Rule for images */
    IMAGE: "image",
    /** Rule for media */
    MEDIA: "media",
    /** Rule for js */
    JS: "js",
    /** Rule for data uri encoded javascript */
    JS_DATA_URI: "js-data-uri",
    /** Rule for ts */
    TS: "ts",
    /** Rule for css */
    CSS: "css",
    /** Rule for less */
    LESS: "less",
    /** Rule for sass */
    SASS: "sass",
    /** Rule for stylus */
    STYLUS: "stylus",
    /** Rule for svg */
    SVG: "svg",
    /** Rule for pug */
    PUG: "pug",
    /** Rule for Vue */
    VUE: "vue",
    /** Rule for yaml */
    YAML: "yaml",
    /** Rule for wasm */
    WASM: "wasm",
    /** Rule for svelte */
    SVELTE: "svelte"
  },
  /** Predefined rule groups */
  ONE_OF: {
    SVG: "svg",
    SVG_URL: "svg-asset-url",
    SVG_ASSET: "svg-asset",
    SVG_REACT: "svg-react",
    SVG_INLINE: "svg-asset-inline"
  },
  /** Predefined loaders */
  USE: {
    /** ts-loader */
    TS: "ts",
    /** css-loader */
    CSS: "css",
    /** sass-loader */
    SASS: "sass",
    /** less-loader */
    LESS: "less",
    /** stylus-loader */
    STYLUS: "stylus",
    /** url-loader */
    URL: "url",
    /** pug-loader */
    PUG: "pug",
    /** vue-loader */
    VUE: "vue",
    /** swc-loader */
    SWC: "swc",
    /** svgr */
    SVGR: "svgr",
    /** plugin-image-compress svgo-loader */
    SVGO: "svgo",
    /** yaml-loader */
    YAML: "yaml",
    /** babel-loader */
    BABEL: "babel",
    /** style-loader */
    STYLE: "style-loader",
    /** svelte-loader */
    SVELTE: "svelte",
    /** postcss-loader */
    POSTCSS: "postcss",
    /** lightningcss-loader */
    LIGHTNINGCSS: "lightningcss",
    /** ignore-css-loader */
    IGNORE_CSS: "ignore-css",
    /** css-modules-typescript-loader */
    CSS_MODULES_TS: "css-modules-typescript",
    /** CssExtractRspackPlugin.loader */
    MINI_CSS_EXTRACT: "mini-css-extract",
    /** resolve-url-loader */
    RESOLVE_URL: "resolve-url-loader",
    /** plugin-image-compress.loader */
    IMAGE_COMPRESS: "image-compress"
  },
  /** Predefined plugins */
  PLUGIN: {
    /** HotModuleReplacementPlugin */
    HMR: "hmr",
    /** CopyWebpackPlugin */
    COPY: "copy",
    /** HtmlWebpackPlugin */
    HTML: "html",
    /** ESLintWebpackPlugin */
    ESLINT: "eslint",
    /** DefinePlugin */
    DEFINE: "define",
    /** ProgressPlugin */
    PROGRESS: "progress",
    /** AppIconPlugin */
    APP_ICON: "app-icon",
    /** WebpackManifestPlugin */
    MANIFEST: "webpack-manifest",
    /** ForkTsCheckerWebpackPlugin */
    TS_CHECKER: "ts-checker",
    /** InlineChunkHtmlPlugin */
    INLINE_HTML: "inline-html",
    /** WebpackBundleAnalyzer */
    BUNDLE_ANALYZER: "bundle-analyze",
    /** ModuleFederationPlugin */
    MODULE_FEDERATION: "module-federation",
    /** HtmlBasicPlugin */
    HTML_BASIC: "html-basic-plugin",
    /** htmlPrefetchPlugin */
    HTML_PREFETCH: "html-prefetch-plugin",
    /** htmlPreloadPlugin */
    HTML_PRELOAD: "html-preload-plugin",
    /** CssExtractRspackPlugin */
    MINI_CSS_EXTRACT: "mini-css-extract",
    /** VueLoaderPlugin */
    VUE_LOADER_PLUGIN: "vue-loader-plugin",
    /** ReactFastRefreshPlugin */
    REACT_FAST_REFRESH: "react-fast-refresh",
    /** ProvidePlugin for node polyfill */
    NODE_POLYFILL_PROVIDE: "node-polyfill-provide",
    /** WebpackSRIPlugin */
    SUBRESOURCE_INTEGRITY: "subresource-integrity",
    /** AssetsRetryPlugin */
    ASSETS_RETRY: "assets-retry",
    /** AsyncChunkRetryPlugin */
    ASYNC_CHUNK_RETRY: "async-chunk-retry",
    /** AutoSetRootFontSizePlugin */
    AUTO_SET_ROOT_SIZE: "auto-set-root-size"
  },
  /** Predefined minimizers */
  MINIMIZER: {
    /** SwcJsMinimizerRspackPlugin */
    JS: "js",
    /** SwcCssMinimizerRspackPlugin */
    CSS: "css"
  },
  /** Predefined resolve plugins */
  RESOLVE_PLUGIN: {
    /** TsConfigPathsPlugin */
    TS_CONFIG_PATHS: "ts-config-paths"
  }
};
function applyScriptCondition({
  rule,
  chain,
  config,
  context,
  includes,
  excludes
}) {
  rule.include.add({
    and: [context.rootPath, { not: NODE_MODULES_REGEX }]
  });
  rule.include.add(TS_AND_JSX_REGEX);
  const target = castArray(chain.get("target"));
  const legacyTarget = ["es5", "es6", "es2015", "es2016"];
  if (legacyTarget.some((item) => target.includes(item))) {
    rule.include.add(/[\\/]@rsbuild[\\/]core[\\/]dist[\\/]/);
  }
  for (const condition of [...includes, ...config.source.include || []]) {
    rule.include.add(condition);
  }
  for (const condition of [...excludes, ...config.source.exclude || []]) {
    rule.exclude.add(condition);
  }
}
export {
  CHAIN_ID,
  DEFAULT_ASSET_PREFIX,
  DEFAULT_BROWSERSLIST,
  JS_REGEX,
  NODE_MODULES_REGEX,
  RspackChain,
  SCRIPT_REGEX,
  TS_AND_JSX_REGEX,
  applyScriptCondition,
  browserslistToESVersion,
  castArray,
  cloneDeep,
  color,
  createCacheGroups,
  createDependenciesRegExp,
  deepmerge,
  fse2 as fse,
  getBrowserslist,
  getBrowserslistWithDefault,
  getCoreJsVersion,
  getNodeEnv,
  getPublicPathFromCompiler,
  isDev,
  isFunction,
  isHtmlDisabled,
  isNil,
  isObject,
  isPlainObject,
  isProd,
  isUsingHMR,
  prettyTime,
  reduceConfigs,
  reduceConfigsAsyncWithContext,
  reduceConfigsMergeContext,
  reduceConfigsWithContext,
  setNodeEnv
};
